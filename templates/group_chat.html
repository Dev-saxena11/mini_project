<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ group_name }} - Chat</title>
    <link rel="stylesheet" href="/static/style.css">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    
</head>
<body>
<header class="navbar">
    <div class="logo">Travel Together</div>
    <nav class="nav-links">
        <a href="/groups">‚Üê Back to Groups</a>
    </nav>
</header>

<main class="group-chat-container">
    <h2>{{ group_name }} - Group Chat</h2>
    <div class="group-chat-messages" id="messages"></div>
    <form method="POST" action="/groups/chat/{{ group_id }}" class="group-chat-form">
        <input type="text" name="message" placeholder="Type a message..." required>
        <button type="submit" class="send-btn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
            </svg>
        </button>
    </form>
</main>


<script>
    const messagesDiv = document.getElementById('messages');
    const chatForm = document.querySelector('.group-chat-form');
    const messageInput = chatForm.querySelector('input[name="message"]');
    const loggedInUsername = "{{ username }}";
<<<<<<< Updated upstream
    
    // This variable will keep track of the last message's date to avoid repeating date separators
    let lastMessageDate = null;

    // --- RENDER INITIAL MESSAGES ---
    // Convert the messages from Flask into a JavaScript object
=======

    // --- RENDER INITIAL MESSAGES ON PAGE LOAD ---
>>>>>>> Stashed changes
    const initialMessages = {{ messages | tojson }};

    // When the page loads, render all the initial messages
    window.addEventListener('load', () => {
<<<<<<< Updated upstream
        initialMessages.forEach(msg => {
            addMessageToUI(msg, false); // 'false' means don't animate initial messages
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight; // Scroll to the bottom
    });


=======
        // Add a small delay to allow the page to render first
        setTimeout(() => {
            initialMessages.forEach(msg => addMessageToUI(msg, false)); // Don't animate initial load
            scrollToBottom(true); // Scroll instantly on load
        }, 100);
    });

>>>>>>> Stashed changes
    // --- HANDLE SENDING NEW MESSAGES ---
    chatForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        const messageText = messageInput.value.trim();
        if (messageText === "") return;

        // Optimistically add the user's message to the UI
        const optimisticMessage = {
            sender_name: loggedInUsername,
            message: messageText,
            timestamp: new Date().toISOString()
        };
        addMessageToUI(optimisticMessage, true);
        const pendingMessageElement = messagesDiv.lastElementChild; // Get the element we just added
        pendingMessageElement.style.opacity = '0.6'; // Mark as 'sending'
        messageInput.value = '';

        try {
            const response = await fetch(`/api/messages/send/{{ group_id }}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: messageText }),
            });
            const result = await response.json();

            if (result.status === 'success') {
<<<<<<< Updated upstream
                addMessageToUI(result.message, true); // 'true' means animate the new message
                messageInput.value = '';
            } else {
                alert("Could not send message.");
=======
                // Message sent successfully, update the UI to confirm
                pendingMessageElement.style.opacity = '1'; 
            } else {
                // If sending failed, indicate an error
                console.error("Error sending message:", result.message);
                pendingMessageElement.style.border = '1px solid red'; // Visual error indicator
>>>>>>> Stashed changes
            }
        } catch (error) {
            console.error("Network error:", error);
            pendingMessageElement.style.border = '1px solid red';
        }
    });

    /**
     * Creates and adds a message bubble and potentially a date separator to the UI.
     * @param {object} msg - The message object.
<<<<<<< Updated upstream
     * @param {boolean} animate - Whether to apply the slide-in animation.
     */
    function addMessageToUI(msg, animate = false) {
        const messageDate = new Date(msg.timestamp).toDateString(); // e.g., "Fri Aug 29 2025"

        // 1. Add a date separator if the day has changed
        if (messageDate !== lastMessageDate) {
            addDateSeparator(new Date(msg.timestamp));
            lastMessageDate = messageDate;
        }

        // 2. Create the message bubble
=======
     * @param {boolean} animate - Whether to apply the entrance animation.
     */
    function addMessageToUI(msg, animate = true) {
>>>>>>> Stashed changes
        const messageContainer = document.createElement('div');
        const isOwnMessage = msg.sender_name === loggedInUsername;
        const messageClass = isOwnMessage ? 'own-message' : 'other-message';
        messageContainer.className = `message-container ${messageClass}`;
<<<<<<< Updated upstream
    
        // Create avatar HTML only for other users
        const avatarHTML = messageClass === 'other-message' 
            ? `<img src="https://placehold.co/40x40/EFEFEF/333333?text=${msg.sender_name.charAt(0)}" alt="Avatar" class="chat-avatar">`
            : '';
=======
        
        // Use a placeholder for avatars. You could later replace this with real user avatars.
        const avatarLetter = msg.sender_name.charAt(0).toUpperCase();
        const avatarColor = isOwnMessage ? '0096c7' : 'ade8f4';
        const avatarTextColor = isOwnMessage ? 'ffffff' : '333333';

        const avatarHTML = `
            <img src="https://placehold.co/40x40/${avatarColor}/${avatarTextColor}?text=${avatarLetter}" alt="Avatar" class="chat-avatar">
        `;
        
        // Don't show the sender's name on their own messages
        const senderNameHTML = !isOwnMessage ? `<strong>${escapeHTML(msg.sender_name)}</strong>` : '';
>>>>>>> Stashed changes

        messageContainer.innerHTML = `
            ${avatarHTML}
            <div class="group-chat-message">
<<<<<<< Updated upstream
                <strong>${msg.sender_name}</strong>
=======
                ${senderNameHTML}
>>>>>>> Stashed changes
                <p>${escapeHTML(msg.message)}</p>
                <small>${formatSimpleTime(msg.timestamp)}</small>
            </div>
        `;
        
        // Remove animation class if we don't want to animate
        if (!animate) {
            const messageBubble = messageContainer.querySelector('.group-chat-message');
            messageBubble.style.animation = 'none';
        }

        messagesDiv.appendChild(messageContainer);
        scrollToBottom();
    }
    
<<<<<<< Updated upstream
    /**
     * Adds a date separator bubble to the chat.
     * @param {Date} date - The date to display.
     */
    function addDateSeparator(date) {
        const separator = document.createElement('div');
        separator.className = 'date-separator';
        
        // Check if the date is today
        const today = new Date().toDateString();
        const yesterday = new Date(Date.now() - 86400000).toDateString();
        
        let dateText = date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
        if (date.toDateString() === today) {
            dateText = 'Today';
        } else if (date.toDateString() === yesterday) {
            dateText = 'Yesterday';
        }
        
        separator.innerHTML = `<span>${dateText}</span>`;
        messagesDiv.appendChild(separator);
    }
    
    /**
     * Formats a timestamp into a simple HH:MM AM/PM format.
     * @param {string} timestamp - The full timestamp string.
     * @returns {string} - The formatted time.
     */
=======
    // --- UTILITY FUNCTIONS ---
    
>>>>>>> Stashed changes
    function formatSimpleTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        });
    }

    function escapeHTML(str) {
        const p = document.createElement("p");
        p.appendChild(document.createTextNode(str));
        return p.innerHTML;
    }

    function scrollToBottom(instant = false) {
        messagesDiv.scrollTo({
            top: messagesDiv.scrollHeight,
            behavior: instant ? 'instant' : 'smooth'
        });
    }
</script>
</body>
</html>
